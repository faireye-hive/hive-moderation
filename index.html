<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Hive Sync ‚Äî IndexedDB & Pagina√ß√£o</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.2/dist/purify.min.js"></script>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <header class="bg-white shadow-md py-4">
      <div class="max-w-6xl mx-auto flex justify-between items-center px-4">
        <h1 class="text-2xl font-bold text-blue-600">Hive Sync</h1>
        <div class="flex items-center gap-3">
          <button
            id="syncBtn"
            class="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg"
          >
            üîÑ Sincronizar
          </button>
          <div class="text-sm text-gray-600">
            Page size:
            <select id="pageSizeSel" class="ml-2 border rounded px-2 py-1">
              <option value="10000">10000</option>
              <option value="5000">5000</option>
              <option value="1000" selected>1000</option>
              <option value="500">500</option>
              <option value="200">200</option>
              <option value="100">100</option>
            </select>
          </div>
        </div>
      </div>
    </header>

    <section
      class="max-w-6xl mx-auto mt-4 px-4 text-sm text-gray-600"
      id="status"
    >
      Carregue uma p√°gina para come√ßar.
    </section>

    <main class="max-w-6xl mx-auto mt-6 px-4">
      <div class="flex items-center justify-between mb-4">
        <div class="flex gap-2 items-center">
          <button
            id="prevBtn"
            class="px-3 py-1 border rounded bg-white"
            disabled
          >
            ‚Üê Anterior
          </button>
          <button
            id="nextBtn"
            class="px-3 py-1 border rounded bg-white"
            disabled
          >
            Pr√≥xima ‚Üí
          </button>
          <span id="pageInfo" class="text-sm text-gray-600 ml-3">P√°gina 1</span>
        </div>

        <div class="flex gap-2 items-center">
          <label class="text-sm text-gray-600">Ir para p√°gina</label>
          <input
            id="gotoInput"
            class="border rounded px-2 py-1 w-20"
            type="number"
            min="1"
            value="1"
          />
          <button id="gotoBtn" class="px-3 py-1 border rounded bg-white">
            Ir
          </button>
        </div>
      </div>

      <div id="postsContainer" class="space-y-4"></div>
    </main>

    <script>
      (() => {
        const REP_API_URL = "https://hafsql-api.mahdiyari.info/reputations/";
        const API_URL = "http://localhost:4000/api/posts";
        const DB_NAME = "HiveSyncDB";
        const DB_VERSION = 8; // aumenta pra recriar com meta
        let db = null;

        let currentPage = 1;
        function pageSize() {
          return Number(pageSizeSel.value || 1000);
        }
        let totalPages = 1;

        // === Refer√™ncias DOM ===
        const statusEl = document.getElementById("status");
        const postsContainer = document.getElementById("postsContainer");
        const syncBtn = document.getElementById("syncBtn");
        const pageSizeSel = document.getElementById("pageSizeSel");
        const prevBtn = document.getElementById("prevBtn");
        const nextBtn = document.getElementById("nextBtn");
        const gotoBtn = document.getElementById("gotoBtn");
        const gotoInput = document.getElementById("gotoInput");
        const pageInfo = document.getElementById("pageInfo");

        const authorFlairs = {
          "hive-watchers": "Scam Hunter",
          spaminator: "Spam Fighter",
          arcange: "Hive Witness",
          curamax: "What? Possible AI?",
          "helios.voter": "Bot Voter",
          rainbowdash4l: "TIP SPAMMER",
          taskmaster4450le: "SPAMMER",
        };

        const spammerList = new Set([
          "spammer-alpha",
          "scam-bot-123",
          "outro-spammer",
          "ai-summaries",
          "hivebuzz",
          "lolzbot",
          "graphene-faucet",
          "ladytoken",
          "redditposh",
          "lstr.alerts",
          "duo-tip",
          "pizzabot",
          // Adicione aqui os nomes exatos dos autores
        ]);

        function setStatus(msg, cls = "text-gray-600") {
          statusEl.className = cls;
          statusEl.textContent = msg;
        }

        async function getTotalPostCount() {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("posts", "readonly");
            const store = tx.objectStore("posts");
            const req = store.count();
            req.onsuccess = () => resolve(req.result);
            req.onerror = (e) => reject(e.target.error);
          });
        }

        // === IndexedDB ===
        function openDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              let postsStore;

              if (!db.objectStoreNames.contains("posts")) {
                postsStore = db.createObjectStore("posts", {
                  keyPath: "permlink",
                });
              } else {
                postsStore = event.target.transaction.objectStore("posts");
              }
              // Adiciona o √≠ndice 'by_created' no campo 'created'
              if (!postsStore.indexNames.contains("by_created")) {
                postsStore.createIndex("by_created", "created");
              }

              if (!db.objectStoreNames.contains("reputations")) {
                db.createObjectStore("reputations", { keyPath: "account" });
              }

              if (!db.objectStoreNames.contains("meta")) {
                db.createObjectStore("meta", { keyPath: "key" });
              }
              console.log(
                "üì¶ Stores criadas/confirmadas:",
                db.objectStoreNames
              );
            };

            request.onsuccess = (event) => {
              db = event.target.result;
              console.log("‚úÖ Banco aberto com sucesso:", db);
              resolve(db);
            };

            request.onerror = (event) => {
              console.error("‚ùå Erro ao abrir DB:", event.target.error);
              reject(event.target.error);
            };
          });
        }

        async function getDB() {
          if (db) return db;
          db = await openDB();
          return db;
        }

        async function savePosts(posts) {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("posts", "readwrite");
            const store = tx.objectStore("posts");
            posts.forEach((p) => store.put(p));
            tx.oncomplete = () => resolve();
            tx.onerror = (e) => reject(e.target.error);
          });
        }

        async function getAllPosts() {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("posts", "readonly");
            const store = tx.objectStore("posts");
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = (e) => reject(e.target.error);
          });
        }

        async function getLastSyncedDate() {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("meta", "readonly");
            const store = tx.objectStore("meta");
            const req = store.get("lastSynced");
            req.onsuccess = () => resolve(req.result ? req.result.value : null);
            req.onerror = () => reject(req.error);
          });
        }

        async function setLastSyncedDate(date) {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("meta", "readwrite");
            const store = tx.objectStore("meta");
            store.put({ key: "lastSynced", value: date });
            tx.oncomplete = resolve;
            tx.onerror = (e) => reject(e.target.error);
          });
        }

        // === Reputa√ß√£o ===
        async function getReputationFromCache(account) {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("reputations", "readonly");
            const store = tx.objectStore("reputations");
            const req = store.get(account);

            req.onsuccess = () => {
              resolve(req.result ? req.result.reputation : null);
            };
            req.onerror = (e) => reject(e.target.error);
          });
        }

        async function saveReputationToCache(account, reputation) {
          const db = await getDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction("reputations", "readwrite");
            const store = tx.objectStore("reputations");

            store.put({ account, reputation });
            tx.oncomplete = resolve;
            tx.onerror = (e) => reject(e.target.error);
          });
        }

        /**
         * Retorna a reputa√ß√£o, buscando primeiro no cache e depois na API.
         * @param {string} account - O nome da conta.
         * @returns {Promise<string>} A reputa√ß√£o formatada como string.
         */
        async function getReputationCached(account) {
          try {
            // 1. Tenta buscar no cache
            const cachedReputation = await getReputationFromCache(account);
            if (cachedReputation) {
              return cachedReputation;
            }

            // 2. Se n√£o estiver no cache, busca na API
            const url = `${REP_API_URL}${String(account)}`;
            const resp = await fetch(url);
            if (!resp.ok) {
              throw new Error("HTTP " + resp.status);
            }
            const data = await resp.json();

            // A API retorna um objeto com 'reputation', que √© um n√∫mero.
            // Se data.reputation for undefined, String(undefined) vira "undefined".
            // Vamos garantir que isso n√£o aconte√ßa:
            const reputation = String(data.toFixed(0) || "25"); // Usa 25 (padr√£o) se a API falhar

            console.log(reputation);
            // 3. Salva no cache para uso futuro
            await saveReputationToCache(account, reputation);

            return reputation;
          } catch (error) {
            // Se QUALQUER coisa acima falhar (cache ou rede), ca√≠mos aqui.
            console.error(
              `‚ùå Erro ao buscar reputa√ß√£o para ${account}:`,
              error
            );
            // Retorna um valor padr√£o para n√£o quebrar o layout
            return "Erro";
          }
        }

        // === Sincroniza√ß√£o ===
        async function syncFromServer() {
          const lastDate = await getLastSyncedDate();
          let url = `${API_URL}?limit=${pageSize()}`;
          if (lastDate) url += `&since=${encodeURIComponent(lastDate)}`;
          setStatus(
            `üîÑ Sincronizando com servidor... (since=${lastDate || "nenhum"})`,
            "text-blue-600"
          );

          const resp = await fetch(url);
          if (!resp.ok) throw new Error("HTTP " + resp.status);
          const j = await resp.json();
          const items = j.items || j;

          if (items.length === 0) {
            setStatus(
              "‚úÖ Nenhum novo post para sincronizar.",
              "text-green-600"
            );
            return;
          }

          await savePosts(items);
          const newestDate = items.reduce(
            (max, p) => (new Date(p.created) > new Date(max) ? p.created : max),
            lastDate || items[0].created
          );
          await setLastSyncedDate(newestDate);
          setStatus(
            `‚úÖ Sincronizados ${items.length} novos posts. √öltimo: ${new Date(
              newestDate
            ).toLocaleString()}`,
            "text-green-600"
          );
        }

        async function getPage(page) {
          const db = await getDB();
          const items = [];
          const limit = pageSize();
          const offset = (page - 1) * limit;

          return new Promise((resolve, reject) => {
            const tx = db.transaction("posts", "readonly");
            const store = tx.objectStore("posts");
            const index = store.index("by_created"); // Usa o √≠ndice
            const req = index.openCursor(null, "prev"); // 'prev' = ordem descendente (mais novo primeiro)
            let advanced = false;

            req.onsuccess = (event) => {
              const cursor = event.target.result;
              if (!cursor) {
                resolve(items); // Acabaram os itens
                return;
              }

              // Pula os itens das p√°ginas anteriores (offset)
              if (!advanced && offset > 0) {
                advanced = true;
                cursor.advance(offset); // Pula 'offset' itens
                return; // onsuccess ser√° chamado novamente na posi√ß√£o correta
              }

              // Adiciona itens at√© o limite da p√°gina
              if (items.length < limit) {
                items.push(cursor.value);
                cursor.continue(); // Vai para o pr√≥ximo item
              } else {
                resolve(items); // P√°gina est√° cheia
              }
            };
            req.onerror = (e) => reject(e.target.error);
          });
        }

        async function countPosts() {
          const allpost = await getAllPosts();
          console.log("allpost");
          console.log(allpost);

          const counts = {};
          allpost.forEach((p) => {
            counts[p.author] = (counts[p.author] || 0) + 1;
          });

          const ranked = Object.entries(counts).sort((a, b) => b[1] - a[1]);
          console.log(ranked);

          return ranked;
        }
        async function refreshPage() {
          setStatus(`üîÑ Carregando p√°gina ${currentPage}...`, "text-blue-600");

          // Busca os itens da p√°gina E o total de posts em paralelo
          const [items, total] = await Promise.all([
            getPage(currentPage),
            getTotalPostCount(),
          ]);

          await renderPosts(items);
          updateControls(total); // Passa o total para atualizar os controles

          if (items.length > 0) {
            setStatus(`P√°gina ${currentPage} carregada.`, "text-gray-600");
          } else if (total > 0) {
            setStatus(`P√°gina ${currentPage} est√° vazia.`, "text-gray-500");
          } else {
            setStatus(
              "Nenhum post encontrado. Sincronize para come√ßar.",
              "text-gray-500"
            );
          }
        }
        function normalizeName(name) {
          return name
            .toLowerCase() // opcional, pra padronizar
            .replace(/[^a-z0-9_]/gi, "_"); // substitui tudo que n√£o for letra/n√∫mero/_ por "_"
        }

        async function getReputation(account) {
          try {
            // 1Ô∏è‚É£ tenta pegar do cache
            const cached = await getReputationFromCache(account);
            if (cached !== null) {
              return { account, data: cached };
            }

            // 2Ô∏è‚É£ se n√£o tiver no cache, busca na API
            const url = `${REP_API_URL}${account}`;
            const resp = await fetch(url);
            if (!resp.ok) throw new Error("HTTP " + resp.status);

            const value = await resp.json(); // API retorna n√∫mero cru

            // 3Ô∏è‚É£ converte para inteiro e salva
            const rep = Number(value).toFixed(0);
            await saveReputationToCache(account, rep);

            return { account, data: rep };
          } catch (err) {
            console.error("Erro ao buscar reputa√ß√£o:", err);
            return { account, data: 25 }; // fallback
          }
        }
        async function renderPosts(items) {
          //countPosts();
          postsContainer.innerHTML = "";
          if (!items.length) {
            postsContainer.innerHTML =
              '<div class="py-8 text-center text-gray-500">Nenhum post nesta p√°gina.</div>';
            return;
          }
          let reputations = {};

          for (const p of items) {
            reputations[p.author] = await getReputation(p.author);
          }
          //reputations = Object.values(reputations);

          items.forEach((p, index) => {
            if (spammerList.has(p.author)) return;

            const currentReputation = reputations[p.author]?.data ?? 25;
            if (currentReputation >= 50) return;

            const repDisplay = currentReputation
              ? `<span class="text-xs ml-1 text-gray-400">(${currentReputation})</span>`
              : "";

            const card = document.createElement("article");
            card.className = "bg-white shadow p-4 rounded-lg";

            const flairText = authorFlairs[p.author];
            const flairHtml = flairText
              ? `<span class="ml-2 px-1.5 py-0.5 text-xs font-semibold bg-red-100 text-red-800 rounded-full">${escapeHtml(
                  flairText
                )}</span>`
              : ""; // Se n√£o, retorna uma string vazia

            const title = escapeHtml(p.title || "(sem t√≠tulo)");
            const payout = escapeHtml(p.pending_payout_value || "0 HIVE");
            const bodyPreview = escapeHtml((p.body || "").slice(0, 400));
            const created = p.created
              ? new Date(p.created).toLocaleString()
              : "-";
            const escapedCreated = escapeHtml(created);

            const rootTag = p.parent_author
              ? `<span class="px-2 py-0.5 text-xs bg-yellow-100 text-yellow-800 rounded">Reply</span>`
              : `<span class="px-2 py-0.5 text-xs bg-green-100 text-green-800 rounded">Post raiz</span>`;
            card.innerHTML = `
        <div class="flex justify-between">
          <div>
            <h3 class="text-lg font-semibold">${title}</h3>
            <div class="text-xs text-gray-500">Por <b>${escapeHtml(
              p.author
            )}</b> Rep: ${repDisplay} Flair: ${flairHtml} <span class="mx-2">‚Ä¢</span> ${escapedCreated}</div>
          </div>
          ${rootTag}
        </div>

        <div class="mt-3 text-gray-700">${bodyPreview}${
              p.body && p.body.length > 400 ? "‚Ä¶" : ""
            }</div>  <div class="mt-3 text-red-700">‚Ä¢ $${payout}</div>
      `;
            postsContainer.appendChild(card);
          });
        }

        function escapeHtml(s, allowHtml = false) {
          s = String(s || "");

          // Se DOMPurify estiver dispon√≠vel, usa ele
          if (typeof DOMPurify !== "undefined") {
            // Se allowHtml for false, remove TODAS as tags (modo texto puro)
            return DOMPurify.sanitize(s, allowHtml ? {} : { ALLOWED_TAGS: [] });
          }

          // Fallback manual (caso DOMPurify n√£o esteja carregado)
          return s
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#39;");
        }

        function updateControls(total) {
          totalPages = Math.ceil(total / pageSize());
          pageInfo.textContent = `P√°gina ${currentPage} de ${totalPages}`;
          prevBtn.disabled = currentPage <= 1;
          nextBtn.disabled = currentPage >= totalPages;
          gotoInput.value = currentPage; // Sincroniza o input com a p√°gina atual
        }
        async function deleteOldPosts() {
          const db = await getDB();

          // 1. Calcular a data de corte
          // O campo 'created' √© uma string ISO (ex: "2024-01-01T10:00:00").
          // Podemos usar um objeto Date para criar o range.
          const cutoffTime = new Date().getTime() - 24 * 60 * 60 * 1000;
          const cutoffDate = new Date(cutoffTime);

          console.log(
            `üßπ Deletando posts mais antigos que ${cutoffDate.toLocaleString()}`
          );

          return new Promise((resolve, reject) => {
            // 2. Abrir transa√ß√£o em modo "readwrite"
            const tx = db.transaction("posts", "readwrite");
            const store = tx.objectStore("posts");
            const index = store.index("by_created");

            // 3. Criar um range: tudo que for *menor que ou igual a* data de corte
            const range = IDBKeyRange.upperBound(cutoffDate.toISOString());

            const req = index.openCursor(range); // Abre cursor no √≠ndice
            let deleteCount = 0;

            req.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                // 4. Encontrou um post antigo: delete!
                cursor.delete();
                deleteCount++;
                cursor.continue(); // Vai para o pr√≥ximo item no range
              } else {
                // 5. Cursor terminou (n√£o h√° mais posts antigos)
                console.log(`‚úÖ ${deleteCount} posts antigos deletados.`);
                resolve(deleteCount);
              }
            };

            req.onerror = (e) => {
              console.error(
                "‚ùå Erro ao deletar posts antigos:",
                e.target.error
              );
              reject(e.target.error);
            };
          });
        }

        // === Eventos ===
        prevBtn.onclick = () => {
          if (currentPage > 1) {
            currentPage--;
            refreshPage();
          }
        };
        nextBtn.onclick = () => {
          if (currentPage < totalPages) {
            // Usa a vari√°vel global 'totalPages'
            currentPage++;
            refreshPage();
          }
        };
        gotoBtn.onclick = async () => {
          // Busca o total para saber o limite m√°ximo da p√°gina
          const total = await getTotalPostCount();
          totalPages = Math.ceil(total / pageSize());
          currentPage = Math.max(
            1,
            Math.min(Number(gotoInput.value), totalPages || 1)
          );
          refreshPage();
        };
        pageSizeSel.onchange = () => {
          currentPage = 1; // Volta para a p√°gina 1
          refreshPage();
        };
        syncBtn.onclick = async () => {
          // Adiciona feedback de loading
          syncBtn.disabled = true;
          syncBtn.textContent = "Sincronizando...";

          await syncFromServer();
          await deleteOldPosts();

          // Reseta para a p√°gina 1 se a p√°gina atual n√£o existir mais (ex: mudou page size)
          const total = await getTotalPostCount();
          totalPages = Math.ceil(total / pageSize());
          if (currentPage > totalPages) currentPage = 1;

          await refreshPage(); // Atualiza a visualiza√ß√£o

          syncBtn.disabled = false;
          syncBtn.textContent = "üîÑ Sincronizar";
        };
        // === Inicializa√ß√£o ===
        (async function init() {
          db = await openDB();
          setStatus("üìÇ Banco de dados carregado (IndexedDB).");
          await deleteOldPosts();
          await syncFromServer(); // Sincroniza primeiro
          currentPage = 1;
          await refreshPage(); // Depois carrega a p√°gina 1
        })();
      })();
    </script>
  </body>
</html>
